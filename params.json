{"name":"Fintrospect","tagline":"","body":"Fintrospect \r\n===========\r\n<a href=\"https://travis-ci.org/daviddenton/fintrospect\" target=\"_top\">\r\n<img src=\"https://travis-ci.org/daviddenton/fintrospect.svg?branch=master\"/></a> \r\n<a href=\"https://coveralls.io/r/daviddenton/fintrospect?branch=master\" target=\"_top\"><img src=\"https://coveralls.io/repos/daviddenton/fintrospect/badge.svg?branch=master\"/></a> \r\n<a href=\"https://bintray.com/daviddenton/maven/fintrospect/_latestVersion\" target=\"_top\"><img src=\"https://api.bintray.com/packages/daviddenton/maven/fintrospect/images/download.svg\"/></a> \r\n<a href=\"https://bintray.com/daviddenton/maven/fintrospect/view?source=watch\" target=\"_top\"><img src=\"https://www.bintray.com/docs/images/bintray_badge_color.png\"/></a> \r\n\r\n\r\nFintrospect is a bolt-on library for use with the [Finagle](http://twitter.github.io/finagle/) RPC framework from Twitter. It was developed out of a desire to provide a pleasant API for describing HTTP request routing in combination with statically-typed documentation which could be verified at compile time and auto-generated at runtime (and thus avoiding the stale documentation risk that exists with manually written docs).\r\n\r\nUsing this library, you can:\r\n- Define individual HTTP routes and compose them into sensible context-based modules.\r\n- Declare both required and optional parameters to be used in the following locations: ```Path/Header/Query/Form/Body```. Retrieval of the parameters is simple and type-safe (```[T]``` for required, ```Option[T]``` for optional). Custom datatypes \r\nfor parameters are supported.\r\n- Automatically generate documentation in a variety of formats (e.g. [Swagger](http://swagger.io/) v1.2 and v2.0). Pluggable architecture for adding your own format renderers (e.g other JSON, XML).\r\n- Endpoints automatically verify the presence and validity of both optional and required parameters. If any parameters are missing or invalid, a ```BAD_REQUEST``` response is generated - meaning that no extra validation code is required for these parameters in your controller code.\r\n- The library provide identification HTTP headers for dynamic-path based endpoints, removing all dynamic path elements. This allows, for example, calls to particular endpoints to be grouped for metric purposes. e.g. ```/search/author/rowling -> /search/author/{name}```.\r\n\r\n###Get it\r\nAdd the following lines to ```build.sbt```. Note that this library doesn't depend on a particular version of Finagle,\r\nand it has only been tested with the version below:\r\n\r\n```scala\r\nresolvers += \"JCenter\" at \"https://jcenter.bintray.com\"\r\nlibraryDependencies += \"com.twitter\" %% \"finagle-http\" % \"6.25.0\"\r\nlibraryDependencies += \"io.github.daviddenton\" %% \"fintrospect\" % \"X.X.X\"\r\n```\r\n\r\n###See it\r\nSee the [example code](https://github.com/daviddenton/fintrospect/tree/master/src/test/scala/examples).\r\n\r\n###Learn it\r\nAdding Fintrospect routes to a Finagle HTTP server is simple. For this example, we'll imagine a Library application (see the example above for the full code) which will be rendering Swagger v2 documentation.\r\n#####Define a module to live at ```http://{host}:8080/library```\r\nThis module will have a single endpoint ```search```:\r\n\r\n```scala\r\nval apiInfo = ApiInfo(\"Library Example\", \"1.0\", Option(\"Simple description\"))\r\nval renderer = Swagger2dot0Json(apiInfo) // choose your renderer implementation\r\nval libraryModule = FintrospectModule(Root / \"library\", renderer)\r\n    .withRoute(new BookSearch(new BookRepo()).route)\r\nval service = FintrospectModule.toService(libraryModule)\r\nHttp.serve(\":8080\", new CorsFilter(Cors.UnsafePermissivePolicy).andThen(service))\r\n```\r\n\r\n#####Define the endpoint\r\nThis example is quite contrived (and almost all the code is optional) but shows the kind of thing that can be done. Note the use of the example response object, which will be broken down to provide the JSON model for the Swagger documentation.\r\n\r\n```scala\r\nclass BookSearch(books: Books) {\r\n  private val maxPages = Query.optional.int(\"maxPages\", \"max number of pages in book\")\r\n  private val minPages = FormField.optional.int(\"minPages\", \"min number of pages in book\")\r\n  private val titleTerm = FormField.required.string(\"term\", \"the part of the title to look for\")\r\n  private val form = Body.form(minPages, titleTerm)\r\n\r\n  private def search() = new Service[HttpRequest, HttpResponse] {\r\n    override def apply(request: HttpRequest): Future[HttpResponse] = {\r\n      val requestForm = form.from(request)\r\n      Ok(array(books.search(minPages.from(requestForm).getOrElse(MIN_VALUE),\r\n        maxPages.from(request).getOrElse(MAX_VALUE),\r\n        titleTerm.from(requestForm)).map(_.toJson)))\r\n    }\r\n  }\r\n\r\n  val route = DescribedRoute(\"search for books\")\r\n    .taking(maxPages)\r\n    .body(form)\r\n    .returning(OK -> \"we found your book\", array(Book(\"a book\", \"authorName\", 99).toJson))\r\n    .returning(OK -> \"results\", BAD_REQUEST -> \"invalid request\")\r\n    .producing(APPLICATION_JSON)\r\n    .at(POST) / \"search\" bindTo search\r\n}\r\n```\r\n\r\n#####View the generated documentation\r\nThe auto-generated documentation lives at the root of the module, so point the Swagger UI at ```http://{host}:8080/library``` to see it.\r\n\r\n#####Test it\r\nFintrospect ships with a testing trait ```TestingFintrospectRoute```, which you can mix into your tests in order to validate your routes.\r\n\r\n###Upgrading?\r\nSee the [Roadmap/Release Notes/Migration Guide](https://github.com/daviddenton/fintrospect/blob/master/RELEASE.md)\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}